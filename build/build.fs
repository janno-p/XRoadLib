open Fake.Api
open Fake.Core
open Fake.Core.TargetOperators
open Fake.Documentation
open Fake.DotNet
open Fake.IO
open Fake.IO.FileSystemOperators
open Fake.IO.Globbing.Operators
open Fake.Tools

// Git configuration (used for publishing documentation in gh-pages branch)
// The profile where the project is posted
let gitOwner = "janno-p"
let gitHome = "https://github.com/" + gitOwner

// The name of the project on GitHub
let gitName = "XRoadLib"

// Strong name key file for assembly signing
let keyFile = "src" </> "XRoadLib.snk"

// Read additional information from the release notes document
let release = ReleaseNotes.load "RELEASE_NOTES.md"

let packageVersion = Environment.environVarOrDefault "RELEASE_VERSION" release.NugetVersion

let packageNotes =
    Environment.environVarOrNone "RELEASE_NOTES"
    |> Option.map
        (fun notes ->
            let delimiter =
                if notes.IndexOf("\r\n") > 0 then "\r\n"
                elif notes.IndexOf("\r") > 0 then "\r"
                else "\n"
            notes |> String.splitStr delimiter
        )
    |> Option.defaultValue release.Notes

let packageSemVer = SemVer.parse(packageVersion)

// Projects which will be included in release
let productProjects =
    !! "src/*/*.csproj"

let tempDocsDir = __SOURCE_DIRECTORY__ </> "temp" </> "gh-pages"
let binDir = __SOURCE_DIRECTORY__ </> "bin"

// --------------------------------------------------------------------------------------
// Remove files generated by previous build

let clean _ =
    !! "src/*/bin"
    ++ "test/*/bin"
    ++ "bin"
    ++ "temp"
    |> Shell.cleanDirs

// --------------------------------------------------------------------------------------
// Builds product assemblies in release mode

let ``build release`` _ =
    productProjects
    |> Seq.iter (fun proj ->
        DotNet.restore id proj
        DotNet.build
            (fun p ->
                { p with
                    Common = { p.Common with CustomParams = Some(sprintf "/p:Version=%s" packageVersion) }
                    Configuration = DotNet.BuildConfiguration.Release })
            proj
    )

// --------------------------------------------------------------------------------------
// Run tests for all target framework versions

let ``run tests`` _ =
    let testProjects =
        [
            ("test", "XRoadLib.Tests", ["net472"; "net6.0"; "net7.0"])
            ("samples", "Calculator.Tests", ["net7.0"])
        ]

    testProjects
    |> List.iter
        (fun (dir, proj, fws) ->
            let testsPath = dir </> proj
            let projectPath = testsPath </> (sprintf "%s.csproj" proj)

            DotNet.restore id projectPath

            fws
            |> List.iter
                (fun fw ->
                    DotNet.build (fun p -> { p with Configuration = DotNet.BuildConfiguration.Debug; Framework = Some(fw) }) projectPath
                    DotNet.exec id "xunit" (testsPath </> "bin" </> "Debug" </> fw </> (sprintf "%s.dll" proj)) |> ignore
                )
        )

// --------------------------------------------------------------------------------------
// Build a NuGet package

let ``nuget pack`` _ =
    productProjects
    |> Seq.iter
        (DotNet.pack
            (fun p ->
                { p with
                    Common = { p.Common with CustomParams = Some(sprintf "/p:Version=%s" packageVersion) }
                    OutputPath = Some(binDir)
                    Configuration = DotNet.BuildConfiguration.Release
                    VersionSuffix = packageSemVer.PreRelease |> Option.map (fun v -> v.Origin) })
        )

let ``nuget publish`` _ =
    let apiKey = Environment.environVarOrFail "NUGET_KEY"
    !! (binDir </> "*.nupkg")
    |> Seq.iter (DotNet.nugetPush (fun p -> p.WithPushParams({ p.PushParams with ApiKey = Some(apiKey) })))

// --------------------------------------------------------------------------------------
// Generate documentation

let docfx =
    DocFx.exec
        (fun p -> { p with DocFxPath = Environment.environVar "USERPROFILE" </> ".nuget" </> "packages" </> "docfx.console" </> "2.58.5" </> "tools" </> "docfx.exe" })

let ``generate help`` _ =
    Shell.rm "docs/articles/release-notes.md"
    Shell.copyFile "docs/articles/" "RELEASE_NOTES.md"
    Shell.rename "docs/articles/release-notes.md" "docs/articles/RELEASE_NOTES.md"

    Shell.rm "docs/articles/license.md"
    Shell.copyFile "docs/articles/" "LICENSE.md"
    Shell.rename "docs/articles/license.md" "docs/articles/LICENSE.md"

let ``clean docs`` _ =
    Shell.cleanDirs [ tempDocsDir ]

let ``serve docs`` _ =
    docfx "serve" tempDocsDir

let ``generate docs`` _ =
    docfx (__SOURCE_DIRECTORY__ </> "docs" </> "docfx.json") ""

let ``release docs`` _ =
    Shell.cleanDirs [ tempDocsDir ]
    Git.Repository.cloneSingleBranch "" (sprintf "%s/%s.git" gitHome gitName) "gh-pages" tempDocsDir
    docfx (__SOURCE_DIRECTORY__ </> "docs" </> "docfx.json") ""
    Git.Staging.stageAll tempDocsDir
    Git.Commit.exec tempDocsDir (sprintf "Update generated documentation for version %s" packageVersion)
    Git.Branches.push tempDocsDir

// --------------------------------------------------------------------------------------
// Release Scripts

let ``check key file`` _ =
    if not (Shell.testFile keyFile) then
        failwithf "Assembly strong name key file `%s` is not present." keyFile

let ``github release`` _ =
    let token = Environment.environVarOrFail "GITHUB_TOKEN"

    let remote =
        Git.CommandHelper.getGitResult "" "remote -v"
        |> Seq.filter (fun (s: string) -> s.EndsWith("(push)"))
        |> Seq.tryFind (fun (s: string) -> s.Contains(gitOwner + "/" + gitName))
        |> function None -> gitHome + "/" + gitName | Some (s: string) -> s.Split().[0]

    Git.Staging.stageAll ""
    Git.Commit.exec "" (sprintf "Bump version to %s" packageVersion)
    Git.Branches.pushBranch "" remote (Git.Information.getBranchName "")

    Git.Branches.tag "" packageVersion
    Git.Branches.pushTag "" remote packageVersion

    // release on github
    GitHub.createClientWithToken token
    |> GitHub.draftNewRelease gitOwner gitName packageVersion (packageSemVer.PreRelease <> None) packageNotes
    // |> GitHub.uploadFile "PATH_TO_FILE"
    |> GitHub.publishDraft
    |> Async.RunSynchronously

let initTargets () =
    let (==>!) x y = x ==> y |> ignore
    let (=?>!) x y = x =?> y |> ignore
    
    Target.create "Clean" clean
    Target.create "BuildRelease" ``build release``
    Target.create "RunTests" ``run tests``
    Target.create "NuGet" ``nuget pack``
    Target.create "PublishNuget" ``nuget publish``
    Target.create "GenerateHelp" ``generate help``
    Target.create "CleanDocs" ``clean docs``
    Target.create "Serve" ``serve docs``
    
    Target.description "Generate the documentation"
    Target.create "GenerateDocs" ``generate docs``
    
    Target.create "ReleaseDocs" ``release docs``
    Target.create "CheckKeyFile" ``check key file``
    Target.create "Release" ``github release``
    Target.create "BuildPackage" ignore
    Target.create "All" ignore
    
    Target.create "List" (fun _ -> Target.listAvailable())

    "Clean"
        ==> "RunTests"
        ==> "BuildRelease"
        ==> "GenerateDocs"
        ==> "All"
        =?>! ("ReleaseDocs", BuildServer.isLocalBuild)

    "All"
        ==> "NuGet"
        ==>! "BuildPackage"

    "CleanDocs"
        ==> "GenerateHelp"
        ==>! "GenerateDocs"

    "CheckKeyFile"
        ==>! "Release"

    "ReleaseDocs"
        ==>! "Release"

    "BuildPackage"
        ==> "PublishNuget"
        ==>! "Release"

[<EntryPoint>]
let main argv =
    argv
    |> Array.toList
    |> Context.FakeExecutionContext.Create false "build.fsx"
    |> Context.RuntimeContext.Fake
    |> Context.setExecutionContext
    initTargets()
    Target.runOrDefaultWithArguments "List"
    0
