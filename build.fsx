#r "paket: groupref Build //"

#load "./.fake/build.fsx/intellisense.fsx"
#load "./paket-files/build/fsharp/FAKE/modules/Octokit/Octokit.fsx"

#if INTERACTIVE
#r "netstandard"
#endif

open Fake.Core
open Fake.Core.TargetOperators
open Fake.Documentation
open Fake.DotNet
open Fake.IO
open Fake.IO.FileSystemOperators
open Fake.IO.Globbing.Operators
open Fake.Tools
open Octokit
open System
open System.IO

// Git configuration (used for publishing documentation in gh-pages branch)
// The profile where the project is posted
let gitOwner = "janno-p"
let gitHome = "https://github.com/" + gitOwner

// The name of the project on GitHub
let gitName = "XRoadLib"

// The url for the raw files hosted
let gitRaw = Environment.environVarOrDefault "gitRaw" ("https://raw.github.com/" + gitOwner)

// Strong name key file for assembly signing
let keyFile = "src" </> "XRoadLib.snk"

// Read additional information from the release notes document
let release = ReleaseNotes.load "RELEASE_NOTES.md"

// Projects which will be included in release
let productProjects =
    !! "src/*/*.csproj"

let docFxToolPath = __SOURCE_DIRECTORY__ </> "paket-files" </> "build" </> "github.com" </> "docfx.exe"
let tempDocsDir = __SOURCE_DIRECTORY__ </> "temp" </> "gh-pages"

// --------------------------------------------------------------------------------------
// Remove files generated by previous build

Target.create "Clean" (fun _ ->
    !! "src/*/bin"
    ++ "test/*/bin"
    ++ "bin"
    ++ "temp"
    |> Shell.cleanDirs
)

// --------------------------------------------------------------------------------------
// Builds product assemblies in release mode

Target.create "BuildRelease" (fun _ ->
    productProjects
    |> Seq.iter (fun proj ->
        DotNet.restore id proj
        DotNet.build
            (fun p ->
                { p with
                    Common = { p.Common with CustomParams = Some(sprintf "/p:Version=%s" release.NugetVersion) }
                    Configuration = DotNet.BuildConfiguration.Release })
            proj
    )
)

// --------------------------------------------------------------------------------------
// Copies binaries from default location to expected bin folder
// But keeps a subdirectory structure for each project in the
// src folder to support multiple project outputs

Target.create "CopyBinaries" (fun _ ->
    productProjects
    |> Seq.map (fun f -> Path.GetDirectoryName(f))
    |> Seq.allPairs ["net452"; "net461"]
    |> Seq.filter (fun (fw, d) -> Directory.Exists(d </> "bin" </> "Release" </> fw))
    |> Seq.map (fun (fw, d) -> (d </> "bin" </> "Release" </> fw, "bin" </> DirectoryInfo(d).Name))
    |> Seq.iter (fun (fromDir, toDir) -> Shell.copyDir toDir fromDir (fun _ -> true))
)

// --------------------------------------------------------------------------------------
// Run tests for all target framework versions

Target.create "RunTests" (fun _ ->
    !! "test/*/*.csproj"
    -- "test/XRoadLib.Tests.Contract/XRoadLib.Tests.Contract.csproj"
    |> Seq.iter (fun proj ->
        DotNet.restore id proj
        DotNet.test id proj
    )
)

// --------------------------------------------------------------------------------------
// Build a NuGet package

Target.create "NuGet" (fun _ ->
    productProjects
    |> Seq.iter (fun proj ->
        DotNet.pack
            (fun p ->
                { p with
                    Common = { p.Common with CustomParams = Some(sprintf "/p:Version=%s" release.NugetVersion) }
                    OutputPath = Some(__SOURCE_DIRECTORY__ </> "bin")
                    Configuration = DotNet.BuildConfiguration.Release
                    VersionSuffix = release.SemVer.PreRelease |> Option.map (fun v -> v.Origin) })
            proj
    )
)

Target.create "PublishNuget" (fun _ ->
    Paket.push (fun p -> { p with WorkingDir = "bin" })
)

// --------------------------------------------------------------------------------------
// Generate documentation

Target.create "GenerateHelp" (fun _ ->
    Shell.rm "docs/articles/release-notes.md"
    Shell.copyFile "docs/articles/" "RELEASE_NOTES.md"
    Shell.rename "docs/articles/release-notes.md" "docs/articles/RELEASE_NOTES.md"

    Shell.rm "docs/articles/license.md"
    Shell.copyFile "docs/articles/" "LICENSE.md"
    Shell.rename "docs/articles/license.md" "docs/articles/LICENSE.md"
)

Target.create "CleanDocs" (fun _ ->
    Shell.cleanDirs [ tempDocsDir ]
)

Target.create "Serve" (fun _ ->
    DocFx.serve
        (fun p ->
            { p with
                Common =
                    { p.Common with
                        DocFxPath = docFxToolPath
                        Timeout = TimeSpan.MaxValue } })
)

Target.description "Generate the documentation"
Target.create "GenerateDocs" (fun _ ->
    DocFx.build (fun p -> p.WithCommon(fun o -> { o with DocFxPath = docFxToolPath }))
)

Target.create "ReleaseDocs" (fun _ ->
    Shell.cleanDirs [ tempDocsDir ]
    Git.Repository.cloneSingleBranch "" (sprintf "%s/%s.git" gitHome gitName) "gh-pages" tempDocsDir
    DocFx.build (fun p -> p.WithCommon(fun o -> { o with DocFxPath = docFxToolPath }))
    Git.Staging.stageAll tempDocsDir
    Git.Commit.exec tempDocsDir (sprintf "Update generated documentation for version %s" release.NugetVersion)
    Git.Branches.push tempDocsDir
)

// --------------------------------------------------------------------------------------
// Release Scripts

Target.create "CheckKeyFile" (fun _ ->
    if not (Shell.testFile keyFile) then
        failwithf "Assembly strong name key file `%s` is not present." keyFile
)

Target.create "Release" (fun _ ->
    let user = Environment.environVarOrFail "github-user"
    let pw = Environment.environVarOrFail "github-pw"

    let remote =
        Git.CommandHelper.getGitResult "" "remote -v"
        |> Seq.filter (fun (s: string) -> s.EndsWith("(push)"))
        |> Seq.tryFind (fun (s: string) -> s.Contains(gitOwner + "/" + gitName))
        |> function None -> gitHome + "/" + gitName | Some (s: string) -> s.Split().[0]

    Git.Staging.stageAll ""
    Git.Commit.exec "" (sprintf "Bump version to %s" release.NugetVersion)
    Git.Branches.pushBranch "" remote (Git.Information.getBranchName "")

    Git.Branches.tag "" release.NugetVersion
    Git.Branches.pushTag "" remote release.NugetVersion

    // release on github
    createClient user pw
    |> createDraft gitOwner gitName release.NugetVersion (release.SemVer.PreRelease <> None) release.Notes
    // TODO: |> uploadFile "PATH_TO_FILE"
    |> releaseDraft
    |> Async.RunSynchronously
)

Target.create "BuildPackage" ignore
Target.create "All" ignore

"Clean"
    ==> "RunTests"
    ==> "BuildRelease"
    ==> "CopyBinaries"
    ==> "GenerateDocs"
    ==> "All"
    =?> ("ReleaseDocs", BuildServer.isLocalBuild)

"All"
    ==> "NuGet"
    ==> "BuildPackage"

"CleanDocs"
    ==> "GenerateHelp"
    ==> "GenerateDocs"

"CheckKeyFile"
    ==> "Release"

"ReleaseDocs"
    ==> "Release"

"BuildPackage"
    ==> "PublishNuget"
    ==> "Release"

Target.runOrDefault "All"
